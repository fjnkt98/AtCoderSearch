// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: history.sql

package repository

import (
	"context"
)

const abortBatchHistory = `-- name: AbortBatchHistory :one
UPDATE "batch_histories"
SET
    "status" = 'aborted',
    "finished_at" = NOW()
WHERE
    "id" = $1
RETURNING
    id, name, started_at, finished_at, status, options
`

func (q *Queries) AbortBatchHistory(ctx context.Context, id int64) (BatchHistory, error) {
	row := q.db.QueryRow(ctx, abortBatchHistory, id)
	var i BatchHistory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Status,
		&i.Options,
	)
	return i, err
}

const abortCrawlHistory = `-- name: AbortCrawlHistory :one
UPDATE "submission_crawl_histories"
SET
    "status" = 'aborted',
    "finished_at" = NOW()
WHERE
    "id" = $1
RETURNING
    id, contest_id, started_at, status, finished_at
`

func (q *Queries) AbortCrawlHistory(ctx context.Context, id int64) (SubmissionCrawlHistory, error) {
	row := q.db.QueryRow(ctx, abortCrawlHistory, id)
	var i SubmissionCrawlHistory
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.StartedAt,
		&i.Status,
		&i.FinishedAt,
	)
	return i, err
}

const completeBatchHistory = `-- name: CompleteBatchHistory :one
UPDATE "batch_histories"
SET
    "status" = 'completed',
    "finished_at" = NOW()
WHERE
    "id" = $1
RETURNING
    id, name, started_at, finished_at, status, options
`

func (q *Queries) CompleteBatchHistory(ctx context.Context, id int64) (BatchHistory, error) {
	row := q.db.QueryRow(ctx, completeBatchHistory, id)
	var i BatchHistory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Status,
		&i.Options,
	)
	return i, err
}

const completeCrawlHistory = `-- name: CompleteCrawlHistory :one
UPDATE "submission_crawl_histories"
SET
    "status" = 'completed',
    "finished_at" = NOW()
WHERE
    "id" = $1
RETURNING
    id, contest_id, started_at, status, finished_at
`

func (q *Queries) CompleteCrawlHistory(ctx context.Context, id int64) (SubmissionCrawlHistory, error) {
	row := q.db.QueryRow(ctx, completeCrawlHistory, id)
	var i SubmissionCrawlHistory
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.StartedAt,
		&i.Status,
		&i.FinishedAt,
	)
	return i, err
}

const createBatchHistory = `-- name: CreateBatchHistory :one
INSERT INTO
    "batch_histories" ("name", "started_at", "options")
VALUES
    ($1, NOW(), $2)
RETURNING
    id, name, started_at, finished_at, status, options
`

type CreateBatchHistoryParams struct {
	Name    string `db:"name"`
	Options []byte `db:"options"`
}

func (q *Queries) CreateBatchHistory(ctx context.Context, arg CreateBatchHistoryParams) (BatchHistory, error) {
	row := q.db.QueryRow(ctx, createBatchHistory, arg.Name, arg.Options)
	var i BatchHistory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Status,
		&i.Options,
	)
	return i, err
}

const createCrawlHistory = `-- name: CreateCrawlHistory :one
INSERT INTO
    "submission_crawl_histories" ("contest_id")
VALUES
    ($1)
RETURNING
    id, contest_id, started_at, status, finished_at
`

func (q *Queries) CreateCrawlHistory(ctx context.Context, contestID string) (SubmissionCrawlHistory, error) {
	row := q.db.QueryRow(ctx, createCrawlHistory, contestID)
	var i SubmissionCrawlHistory
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.StartedAt,
		&i.Status,
		&i.FinishedAt,
	)
	return i, err
}

const fetchLatestBatchHistory = `-- name: FetchLatestBatchHistory :one
SELECT
    id, name, started_at, finished_at, status, options
FROM
    "batch_histories"
WHERE
    "name" = $1
    AND "status" = 'completed'
ORDER BY
    "started_at" DESC
LIMIT
    1
`

func (q *Queries) FetchLatestBatchHistory(ctx context.Context, name string) (BatchHistory, error) {
	row := q.db.QueryRow(ctx, fetchLatestBatchHistory, name)
	var i BatchHistory
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Status,
		&i.Options,
	)
	return i, err
}

const fetchLatestCrawlHistory = `-- name: FetchLatestCrawlHistory :one
SELECT
    id, contest_id, started_at, status, finished_at
FROM
    "submission_crawl_histories"
WHERE
    "contest_id" = $1
    AND "status" = 'completed'
ORDER BY
    "started_at" DESC
LIMIT
    1
`

func (q *Queries) FetchLatestCrawlHistory(ctx context.Context, contestID string) (SubmissionCrawlHistory, error) {
	row := q.db.QueryRow(ctx, fetchLatestCrawlHistory, contestID)
	var i SubmissionCrawlHistory
	err := row.Scan(
		&i.ID,
		&i.ContestID,
		&i.StartedAt,
		&i.Status,
		&i.FinishedAt,
	)
	return i, err
}
