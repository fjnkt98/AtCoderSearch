// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package repository

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgconn"
)

const createBatchHistory = `-- name: CreateBatchHistory :one
INSERT INTO
    "batch_history" ("name", "started_at", "options")
VALUES
    ($1, NOW(), $2)
RETURNING
    "id"
`

type CreateBatchHistoryParams struct {
	Name    string `db:"name"`
	Options []byte `db:"options"`
}

func (q *Queries) CreateBatchHistory(ctx context.Context, arg CreateBatchHistoryParams) (int64, error) {
	row := q.db.QueryRow(ctx, createBatchHistory, arg.Name, arg.Options)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createCrawlHistory = `-- name: CreateCrawlHistory :one
INSERT INTO
    "submission_crawl_history" ("started_at", "contest_id")
VALUES
    (
        EXTRACT(
            epoch
            FROM
                NOW()
        ),
        $1
    )
RETURNING
    "started_at",
    "contest_id"
`

type CreateCrawlHistoryRow struct {
	StartedAt int64  `db:"started_at"`
	ContestID string `db:"contest_id"`
}

func (q *Queries) CreateCrawlHistory(ctx context.Context, contestID string) (CreateCrawlHistoryRow, error) {
	row := q.db.QueryRow(ctx, createCrawlHistory, contestID)
	var i CreateCrawlHistoryRow
	err := row.Scan(&i.StartedAt, &i.ContestID)
	return i, err
}

const fetchCategories = `-- name: FetchCategories :many
SELECT DISTINCT
    "category"
FROM
    "contests"
ORDER BY
    "category" ASC
`

func (q *Queries) FetchCategories(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, fetchCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var category string
		if err := rows.Scan(&category); err != nil {
			return nil, err
		}
		items = append(items, category)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchContestIDs = `-- name: FetchContestIDs :many
SELECT
    "contest_id"
FROM
    "contests"
ORDER BY
    "start_epoch_second" DESC
`

func (q *Queries) FetchContestIDs(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, fetchContestIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var contest_id string
		if err := rows.Scan(&contest_id); err != nil {
			return nil, err
		}
		items = append(items, contest_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchContestIDsByCategory = `-- name: FetchContestIDsByCategory :many
SELECT
    "contest_id"
FROM
    "contests"
WHERE
    "category" = ANY ($1::TEXT[])
ORDER BY
    "start_epoch_second" DESC
`

func (q *Queries) FetchContestIDsByCategory(ctx context.Context, category []string) ([]string, error) {
	rows, err := q.db.Query(ctx, fetchContestIDsByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var contest_id string
		if err := rows.Scan(&contest_id); err != nil {
			return nil, err
		}
		items = append(items, contest_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLanguageGroups = `-- name: FetchLanguageGroups :many
SELECT DISTINCT
    "group"
FROM
    "languages"
ORDER BY
    "group" DESC
`

func (q *Queries) FetchLanguageGroups(ctx context.Context) ([]*string, error) {
	rows, err := q.db.Query(ctx, fetchLanguageGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*string
	for rows.Next() {
		var group *string
		if err := rows.Scan(&group); err != nil {
			return nil, err
		}
		items = append(items, group)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLanguages = `-- name: FetchLanguages :many
SELECT
    "language"
FROM
    "languages"
ORDER BY
    "language"
`

func (q *Queries) FetchLanguages(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, fetchLanguages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var language string
		if err := rows.Scan(&language); err != nil {
			return nil, err
		}
		items = append(items, language)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLanguagesByGroup = `-- name: FetchLanguagesByGroup :many
SELECT
    "language"
FROM
    "languages"
WHERE
    "group" = ANY ($1::TEXT[])
ORDER BY
    "language"
`

func (q *Queries) FetchLanguagesByGroup(ctx context.Context, groups []string) ([]string, error) {
	rows, err := q.db.Query(ctx, fetchLanguagesByGroup, groups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var language string
		if err := rows.Scan(&language); err != nil {
			return nil, err
		}
		items = append(items, language)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLatestBatchHistory = `-- name: FetchLatestBatchHistory :one
SELECT
    "id",
    "started_at",
    "finished_at"
FROM
    "batch_history"
WHERE
    "name" = $1
    AND "status" = 'finished'
ORDER BY
    "started_at" DESC
LIMIT
    1
`

type FetchLatestBatchHistoryRow struct {
	ID         int64      `db:"id"`
	StartedAt  time.Time  `db:"started_at"`
	FinishedAt *time.Time `db:"finished_at"`
}

func (q *Queries) FetchLatestBatchHistory(ctx context.Context, name string) (FetchLatestBatchHistoryRow, error) {
	row := q.db.QueryRow(ctx, fetchLatestBatchHistory, name)
	var i FetchLatestBatchHistoryRow
	err := row.Scan(&i.ID, &i.StartedAt, &i.FinishedAt)
	return i, err
}

const fetchLatestCrawlHistory = `-- name: FetchLatestCrawlHistory :one
SELECT
    "started_at"
FROM
    "submission_crawl_history"
WHERE
    "contest_id" = $1
LIMIT
    1
`

func (q *Queries) FetchLatestCrawlHistory(ctx context.Context, contestID string) (int64, error) {
	row := q.db.QueryRow(ctx, fetchLatestCrawlHistory, contestID)
	var started_at int64
	err := row.Scan(&started_at)
	return started_at, err
}

const fetchProblemIDs = `-- name: FetchProblemIDs :many
SELECT
    "problem_id"
FROM
    "problems"
`

func (q *Queries) FetchProblemIDs(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, fetchProblemIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var problem_id string
		if err := rows.Scan(&problem_id); err != nil {
			return nil, err
		}
		items = append(items, problem_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProblemIDsByContestID = `-- name: FetchProblemIDsByContestID :many
SELECT
    "problem_id"
FROM
    "problems"
WHERE
    "contest_id" = ANY ($1::TEXT[])
ORDER BY
    "problem_id" ASC
`

func (q *Queries) FetchProblemIDsByContestID(ctx context.Context, contestID []string) ([]string, error) {
	rows, err := q.db.Query(ctx, fetchProblemIDsByContestID, contestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var problem_id string
		if err := rows.Scan(&problem_id); err != nil {
			return nil, err
		}
		items = append(items, problem_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchRatingByUserID = `-- name: FetchRatingByUserID :one
SELECT
    "rating"
FROM
    "users"
WHERE
    "user_id" = $1
LIMIT
    1
`

func (q *Queries) FetchRatingByUserID(ctx context.Context, userID string) (int32, error) {
	row := q.db.QueryRow(ctx, fetchRatingByUserID, userID)
	var rating int32
	err := row.Scan(&rating)
	return rating, err
}

const insertProblem = `-- name: InsertProblem :execresult
INSERT INTO
    "problems" (
        "problem_id",
        "contest_id",
        "problem_index",
        "name",
        "title",
        "url",
        "html",
        "updated_at"
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7, NOW())
ON CONFLICT ("problem_id") DO
UPDATE
SET
    "contest_id" = EXCLUDED."contest_id",
    "problem_index" = EXCLUDED."problem_index",
    "name" = EXCLUDED."name",
    "title" = EXCLUDED."title",
    "url" = EXCLUDED."url",
    "html" = EXCLUDED."html",
    "updated_at" = NOW()
`

type InsertProblemParams struct {
	ProblemID    string `bulk:"unique" db:"problem_id"`
	ContestID    string `db:"contest_id"`
	ProblemIndex string `db:"problem_index"`
	Name         string `db:"name"`
	Title        string `db:"title"`
	Url          string `db:"url"`
	Html         string `db:"html"`
}

func (q *Queries) InsertProblem(ctx context.Context, arg InsertProblemParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, insertProblem,
		arg.ProblemID,
		arg.ContestID,
		arg.ProblemIndex,
		arg.Name,
		arg.Title,
		arg.Url,
		arg.Html,
	)
}

const updateBatchHistory = `-- name: UpdateBatchHistory :exec
UPDATE "batch_history"
SET
    "finished_at" = NOW(),
    "status" = $1
WHERE
    "id" = $2
`

type UpdateBatchHistoryParams struct {
	Status string `db:"status"`
	ID     int64  `db:"id"`
}

func (q *Queries) UpdateBatchHistory(ctx context.Context, arg UpdateBatchHistoryParams) error {
	_, err := q.db.Exec(ctx, updateBatchHistory, arg.Status, arg.ID)
	return err
}
