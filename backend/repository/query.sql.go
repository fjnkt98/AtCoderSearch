// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package repository

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/lib/pq"
)

const createCrawlHistory = `-- name: CreateCrawlHistory :one
INSERT INTO
    "submission_crawl_history" ("started_at", "contest_id")
VALUES
    (NOW(), $1)
RETURNING
    "started_at",
    "contest_id"
`

type CreateCrawlHistoryRow struct {
	StartedAt int64
	ContestID string
}

func (q *Queries) CreateCrawlHistory(ctx context.Context, contestID string) (CreateCrawlHistoryRow, error) {
	row := q.db.QueryRowContext(ctx, createCrawlHistory, contestID)
	var i CreateCrawlHistoryRow
	err := row.Scan(&i.StartedAt, &i.ContestID)
	return i, err
}

const createUpdateHistory = `-- name: CreateUpdateHistory :one
INSERT INTO
    "update_history" ("domain", "started_at", "options")
VALUES
    ($1, NOW(), $2)
RETURNING
    "id",
    "domain",
    "started_at"
`

type CreateUpdateHistoryParams struct {
	Domain  string
	Options json.RawMessage
}

type CreateUpdateHistoryRow struct {
	ID        int64
	Domain    string
	StartedAt time.Time
}

func (q *Queries) CreateUpdateHistory(ctx context.Context, arg CreateUpdateHistoryParams) (CreateUpdateHistoryRow, error) {
	row := q.db.QueryRowContext(ctx, createUpdateHistory, arg.Domain, arg.Options)
	var i CreateUpdateHistoryRow
	err := row.Scan(&i.ID, &i.Domain, &i.StartedAt)
	return i, err
}

const fetchCategories = `-- name: FetchCategories :many
SELECT DISTINCT
    "category"
FROM
    "contests"
ORDER BY
    "category" ASC
`

func (q *Queries) FetchCategories(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, fetchCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var category string
		if err := rows.Scan(&category); err != nil {
			return nil, err
		}
		items = append(items, category)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchContestIDs = `-- name: FetchContestIDs :many
SELECT
    "contest_id"
FROM
    "contests"
ORDER BY
    "start_epoch_second" DESC
`

func (q *Queries) FetchContestIDs(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, fetchContestIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var contest_id string
		if err := rows.Scan(&contest_id); err != nil {
			return nil, err
		}
		items = append(items, contest_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchContestIDsByCategory = `-- name: FetchContestIDsByCategory :many
SELECT
    "contest_id"
FROM
    "contests"
WHERE
    "category" = ANY ($1::TEXT[])
ORDER BY
    "start_epoch_second" DESC
`

func (q *Queries) FetchContestIDsByCategory(ctx context.Context, category []string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, fetchContestIDsByCategory, pq.Array(category))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var contest_id string
		if err := rows.Scan(&contest_id); err != nil {
			return nil, err
		}
		items = append(items, contest_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLanguageGroups = `-- name: FetchLanguageGroups :many
SELECT DISTINCT
    "group"
FROM
    "languages"
ORDER BY
    "group" DESC
`

func (q *Queries) FetchLanguageGroups(ctx context.Context) ([]sql.NullString, error) {
	rows, err := q.db.QueryContext(ctx, fetchLanguageGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []sql.NullString
	for rows.Next() {
		var group sql.NullString
		if err := rows.Scan(&group); err != nil {
			return nil, err
		}
		items = append(items, group)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLanguages = `-- name: FetchLanguages :many
SELECT
    "language"
FROM
    "languages"
ORDER BY
    "language"
`

func (q *Queries) FetchLanguages(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, fetchLanguages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var language string
		if err := rows.Scan(&language); err != nil {
			return nil, err
		}
		items = append(items, language)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLanguagesByGroup = `-- name: FetchLanguagesByGroup :many
SELECT
    "language"
FROM
    "languages"
WHERE
    "group" = ANY ($1::TEXT[])
ORDER BY
    "language"
`

func (q *Queries) FetchLanguagesByGroup(ctx context.Context, groups []string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, fetchLanguagesByGroup, pq.Array(groups))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var language string
		if err := rows.Scan(&language); err != nil {
			return nil, err
		}
		items = append(items, language)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLatestCrawlHistory = `-- name: FetchLatestCrawlHistory :one
SELECT
    "started_at"
FROM
    "submission_crawl_history"
WHERE
    "contest_id" = $1
LIMIT
    1
`

func (q *Queries) FetchLatestCrawlHistory(ctx context.Context, contestID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, fetchLatestCrawlHistory, contestID)
	var started_at int64
	err := row.Scan(&started_at)
	return started_at, err
}

const fetchLatestUpdateHistory = `-- name: FetchLatestUpdateHistory :one
SELECT
    "id",
    "started_at",
    "finished_at"
FROM
    "update_history"
WHERE
    "domain" = $1
    AND "status" = 'finished'
ORDER BY
    "started_at" DESC
LIMIT
    1
`

type FetchLatestUpdateHistoryRow struct {
	ID         int64
	StartedAt  time.Time
	FinishedAt sql.NullTime
}

func (q *Queries) FetchLatestUpdateHistory(ctx context.Context, domain string) (FetchLatestUpdateHistoryRow, error) {
	row := q.db.QueryRowContext(ctx, fetchLatestUpdateHistory, domain)
	var i FetchLatestUpdateHistoryRow
	err := row.Scan(&i.ID, &i.StartedAt, &i.FinishedAt)
	return i, err
}

const fetchProblemIDs = `-- name: FetchProblemIDs :many
SELECT
    "problem_id"
FROM
    "problems"
`

func (q *Queries) FetchProblemIDs(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, fetchProblemIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var problem_id string
		if err := rows.Scan(&problem_id); err != nil {
			return nil, err
		}
		items = append(items, problem_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProblemIDsByContestID = `-- name: FetchProblemIDsByContestID :many
SELECT
    "problem_id"
FROM
    "problems"
WHERE
    "contest_id" = ANY ($1::TEXT[])
ORDER BY
    "problem_id" ASC
`

func (q *Queries) FetchProblemIDsByContestID(ctx context.Context, contestID []string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, fetchProblemIDsByContestID, pq.Array(contestID))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var problem_id string
		if err := rows.Scan(&problem_id); err != nil {
			return nil, err
		}
		items = append(items, problem_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchRatingByUserName = `-- name: FetchRatingByUserName :one
SELECT
    "rating"
FROM
    "users"
WHERE
    "user_name" = $1
LIMIT
    1
`

func (q *Queries) FetchRatingByUserName(ctx context.Context, userName string) (int32, error) {
	row := q.db.QueryRowContext(ctx, fetchRatingByUserName, userName)
	var rating int32
	err := row.Scan(&rating)
	return rating, err
}

const insertContest = `-- name: InsertContest :execresult
INSERT INTO
    "contests" (
        "contest_id",
        "start_epoch_second",
        "duration_second",
        "title",
        "rate_change",
        "category",
        "updated_at"
    )
VALUES
    ($1, $2, $3, $4, $5, $6, NOW())
ON CONFLICT ("contest_id") DO
UPDATE
SET
    "start_epoch_second" = EXCLUDED."start_epoch_second",
    "duration_second" = EXCLUDED."duration_second",
    "title" = EXCLUDED."title",
    "rate_change" = EXCLUDED."rate_change",
    "category" = EXCLUDED."category",
    "updated_at" = NOW()
`

type InsertContestParams struct {
	ContestID        string
	StartEpochSecond int64
	DurationSecond   int64
	Title            string
	RateChange       string
	Category         string
}

func (q *Queries) InsertContest(ctx context.Context, arg InsertContestParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertContest,
		arg.ContestID,
		arg.StartEpochSecond,
		arg.DurationSecond,
		arg.Title,
		arg.RateChange,
		arg.Category,
	)
}

const insertDifficulty = `-- name: InsertDifficulty :execresult
INSERT INTO
    "difficulties" (
        "problem_id",
        "slope",
        "intercept",
        "variance",
        "difficulty",
        "discrimination",
        "irt_loglikelihood",
        "irt_users",
        "is_experimental",
        "updated_at"
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW())
ON CONFLICT ("problem_id") DO
UPDATE
SET
    "slope" = EXCLUDED."slope",
    "intercept" = EXCLUDED."intercept",
    "variance" = EXCLUDED."variance",
    "difficulty" = EXCLUDED."difficulty",
    "discrimination" = EXCLUDED."discrimination",
    "irt_loglikelihood" = EXCLUDED."irt_loglikelihood",
    "irt_users" = EXCLUDED."irt_users",
    "is_experimental" = EXCLUDED."is_experimental",
    "updated_at" = NOW()
`

type InsertDifficultyParams struct {
	ProblemID        string
	Slope            sql.NullFloat64
	Intercept        sql.NullFloat64
	Variance         sql.NullFloat64
	Difficulty       sql.NullInt32
	Discrimination   sql.NullFloat64
	IrtLoglikelihood sql.NullFloat64
	IrtUsers         sql.NullFloat64
	IsExperimental   sql.NullBool
}

func (q *Queries) InsertDifficulty(ctx context.Context, arg InsertDifficultyParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertDifficulty,
		arg.ProblemID,
		arg.Slope,
		arg.Intercept,
		arg.Variance,
		arg.Difficulty,
		arg.Discrimination,
		arg.IrtLoglikelihood,
		arg.IrtUsers,
		arg.IsExperimental,
	)
}

const insertProblem = `-- name: InsertProblem :execresult
INSERT INTO
    "problems" (
        "problem_id",
        "contest_id",
        "problem_index",
        "name",
        "title",
        "url",
        "html",
        "created_at",
        "updated_at"
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7, NOW(), NOW())
ON CONFLICT ("problem_id") DO
UPDATE
SET
    "contest_id" = EXCLUDED."contest_id",
    "problem_index" = EXCLUDED."problem_index",
    "name" = EXCLUDED."name",
    "title" = EXCLUDED."title",
    "url" = EXCLUDED."url",
    "html" = EXCLUDED."html",
    "updated_at" = NOW()
`

type InsertProblemParams struct {
	ProblemID    string
	ContestID    string
	ProblemIndex string
	Name         string
	Title        string
	Url          string
	Html         string
}

func (q *Queries) InsertProblem(ctx context.Context, arg InsertProblemParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertProblem,
		arg.ProblemID,
		arg.ContestID,
		arg.ProblemIndex,
		arg.Name,
		arg.Title,
		arg.Url,
		arg.Html,
	)
}

const insertSubmission = `-- name: InsertSubmission :execresult
INSERT INTO
    "submissions" (
        "id",
        "epoch_second",
        "problem_id",
        "contest_id",
        "user_id",
        "language",
        "point",
        "length",
        "result",
        "execution_time",
        "crawled_at"
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $7, $8, NOW())
ON CONFLICT ("id") DO
UPDATE
SET
    "epoch_second" = EXCLUDED."epoch_second",
    "problem_id" = EXCLUDED."problem_id",
    "contest_id" = EXCLUDED."contest_id",
    "user_id" = EXCLUDED."user_id",
    "language" = EXCLUDED."language",
    "point" = EXCLUDED."point",
    "length" = EXCLUDED."length",
    "result" = EXCLUDED."result",
    "execution_time" = EXCLUDED."execution_time",
    "crawled_at" = NOW()
`

type InsertSubmissionParams struct {
	ID          int64
	EpochSecond int64
	ProblemID   string
	ContestID   sql.NullString
	UserID      sql.NullString
	Language    sql.NullString
	Point       sql.NullFloat64
	Length      sql.NullInt32
}

func (q *Queries) InsertSubmission(ctx context.Context, arg InsertSubmissionParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertSubmission,
		arg.ID,
		arg.EpochSecond,
		arg.ProblemID,
		arg.ContestID,
		arg.UserID,
		arg.Language,
		arg.Point,
		arg.Length,
	)
}

const insertUser = `-- name: InsertUser :execresult
INSERT INTO
    "users" (
        "user_name",
        "rating",
        "highest_rating",
        "affiliation",
        "birth_year",
        "country",
        "crown",
        "join_count",
        "rank",
        "active_rank",
        "wins",
        "created_at",
        "updated_at"
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $7,
        $8,
        $9,
        NOW(),
        NOW()
    )
ON CONFLICT ("user_name") DO
UPDATE
SET
    "rating" = EXCLUDED."rating",
    "highest_rating" = EXCLUDED."highest_rating",
    "affiliation" = EXCLUDED."affiliation",
    "birth_year" = EXCLUDED."birth_year",
    "country" = EXCLUDED."country",
    "crown" = EXCLUDED."crown",
    "join_count" = EXCLUDED."join_count",
    "rank" = EXCLUDED."rank",
    "active_rank" = EXCLUDED."active_rank",
    "wins" = EXCLUDED."wins",
    "created_at" = NOW(),
    "updated_at" = NOW()
`

type InsertUserParams struct {
	UserName      string
	Rating        int32
	HighestRating int32
	Affiliation   sql.NullString
	BirthYear     sql.NullInt32
	Country       sql.NullString
	Crown         sql.NullString
	JoinCount     int32
	Wins          int32
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertUser,
		arg.UserName,
		arg.Rating,
		arg.HighestRating,
		arg.Affiliation,
		arg.BirthYear,
		arg.Country,
		arg.Crown,
		arg.JoinCount,
		arg.Wins,
	)
}

const updateUpdateHistory = `-- name: UpdateUpdateHistory :exec
UPDATE "update_history"
SET
    "finished_at" = NOW(),
    "status" = $1
WHERE
    "id" = $2
`

type UpdateUpdateHistoryParams struct {
	Status sql.NullString
	ID     int64
}

func (q *Queries) UpdateUpdateHistory(ctx context.Context, arg UpdateUpdateHistoryParams) error {
	_, err := q.db.ExecContext(ctx, updateUpdateHistory, arg.Status, arg.ID)
	return err
}
