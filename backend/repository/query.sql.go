// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package repository

import (
	"context"
	"time"

	"github.com/jackc/pgx/v5/pgconn"
)

const createBatchHistory = `-- name: CreateBatchHistory :one
INSERT INTO
    "batch_history" ("name", "started_at", "options")
VALUES
    ($1, NOW(), $2)
RETURNING
    "id"
`

type CreateBatchHistoryParams struct {
	Name    string `db:"name"`
	Options []byte `db:"options"`
}

func (q *Queries) CreateBatchHistory(ctx context.Context, arg CreateBatchHistoryParams) (int64, error) {
	row := q.db.QueryRow(ctx, createBatchHistory, arg.Name, arg.Options)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createCrawlHistory = `-- name: CreateCrawlHistory :one
INSERT INTO
    "submission_crawl_history" ("started_at", "contest_id")
VALUES
    (NOW(), $1)
RETURNING
    "started_at",
    "contest_id"
`

type CreateCrawlHistoryRow struct {
	StartedAt int64  `db:"started_at"`
	ContestID string `db:"contest_id"`
}

func (q *Queries) CreateCrawlHistory(ctx context.Context, contestID string) (CreateCrawlHistoryRow, error) {
	row := q.db.QueryRow(ctx, createCrawlHistory, contestID)
	var i CreateCrawlHistoryRow
	err := row.Scan(&i.StartedAt, &i.ContestID)
	return i, err
}

const fetchCategories = `-- name: FetchCategories :many
SELECT DISTINCT
    "category"
FROM
    "contests"
ORDER BY
    "category" ASC
`

func (q *Queries) FetchCategories(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, fetchCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var category string
		if err := rows.Scan(&category); err != nil {
			return nil, err
		}
		items = append(items, category)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchContestIDs = `-- name: FetchContestIDs :many
SELECT
    "contest_id"
FROM
    "contests"
ORDER BY
    "start_epoch_second" DESC
`

func (q *Queries) FetchContestIDs(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, fetchContestIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var contest_id string
		if err := rows.Scan(&contest_id); err != nil {
			return nil, err
		}
		items = append(items, contest_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchContestIDsByCategory = `-- name: FetchContestIDsByCategory :many
SELECT
    "contest_id"
FROM
    "contests"
WHERE
    "category" = ANY ($1::TEXT[])
ORDER BY
    "start_epoch_second" DESC
`

func (q *Queries) FetchContestIDsByCategory(ctx context.Context, category []string) ([]string, error) {
	rows, err := q.db.Query(ctx, fetchContestIDsByCategory, category)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var contest_id string
		if err := rows.Scan(&contest_id); err != nil {
			return nil, err
		}
		items = append(items, contest_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLanguageGroups = `-- name: FetchLanguageGroups :many
SELECT DISTINCT
    "group"
FROM
    "languages"
ORDER BY
    "group" DESC
`

func (q *Queries) FetchLanguageGroups(ctx context.Context) ([]*string, error) {
	rows, err := q.db.Query(ctx, fetchLanguageGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*string
	for rows.Next() {
		var group *string
		if err := rows.Scan(&group); err != nil {
			return nil, err
		}
		items = append(items, group)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLanguages = `-- name: FetchLanguages :many
SELECT
    "language"
FROM
    "languages"
ORDER BY
    "language"
`

func (q *Queries) FetchLanguages(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, fetchLanguages)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var language string
		if err := rows.Scan(&language); err != nil {
			return nil, err
		}
		items = append(items, language)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLanguagesByGroup = `-- name: FetchLanguagesByGroup :many
SELECT
    "language"
FROM
    "languages"
WHERE
    "group" = ANY ($1::TEXT[])
ORDER BY
    "language"
`

func (q *Queries) FetchLanguagesByGroup(ctx context.Context, groups []string) ([]string, error) {
	rows, err := q.db.Query(ctx, fetchLanguagesByGroup, groups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var language string
		if err := rows.Scan(&language); err != nil {
			return nil, err
		}
		items = append(items, language)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchLatestBatchHistory = `-- name: FetchLatestBatchHistory :one
SELECT
    "id",
    "started_at",
    "finished_at"
FROM
    "batch_history"
WHERE
    "name" = $1
    AND "status" = 'finished'
ORDER BY
    "started_at" DESC
LIMIT
    1
`

type FetchLatestBatchHistoryRow struct {
	ID         int64      `db:"id"`
	StartedAt  time.Time  `db:"started_at"`
	FinishedAt *time.Time `db:"finished_at"`
}

func (q *Queries) FetchLatestBatchHistory(ctx context.Context, name string) (FetchLatestBatchHistoryRow, error) {
	row := q.db.QueryRow(ctx, fetchLatestBatchHistory, name)
	var i FetchLatestBatchHistoryRow
	err := row.Scan(&i.ID, &i.StartedAt, &i.FinishedAt)
	return i, err
}

const fetchLatestCrawlHistory = `-- name: FetchLatestCrawlHistory :one
SELECT
    "started_at"
FROM
    "submission_crawl_history"
WHERE
    "contest_id" = $1
LIMIT
    1
`

func (q *Queries) FetchLatestCrawlHistory(ctx context.Context, contestID string) (int64, error) {
	row := q.db.QueryRow(ctx, fetchLatestCrawlHistory, contestID)
	var started_at int64
	err := row.Scan(&started_at)
	return started_at, err
}

const fetchProblemIDs = `-- name: FetchProblemIDs :many
SELECT
    "problem_id"
FROM
    "problems"
`

func (q *Queries) FetchProblemIDs(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, fetchProblemIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var problem_id string
		if err := rows.Scan(&problem_id); err != nil {
			return nil, err
		}
		items = append(items, problem_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchProblemIDsByContestID = `-- name: FetchProblemIDsByContestID :many
SELECT
    "problem_id"
FROM
    "problems"
WHERE
    "contest_id" = ANY ($1::TEXT[])
ORDER BY
    "problem_id" ASC
`

func (q *Queries) FetchProblemIDsByContestID(ctx context.Context, contestID []string) ([]string, error) {
	rows, err := q.db.Query(ctx, fetchProblemIDsByContestID, contestID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var problem_id string
		if err := rows.Scan(&problem_id); err != nil {
			return nil, err
		}
		items = append(items, problem_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const fetchRatingByUserName = `-- name: FetchRatingByUserName :one
SELECT
    "rating"
FROM
    "users"
WHERE
    "user_name" = $1
LIMIT
    1
`

func (q *Queries) FetchRatingByUserName(ctx context.Context, userName string) (int32, error) {
	row := q.db.QueryRow(ctx, fetchRatingByUserName, userName)
	var rating int32
	err := row.Scan(&rating)
	return rating, err
}

const insertContest = `-- name: InsertContest :execresult
INSERT INTO
    "contests" (
        "contest_id",
        "start_epoch_second",
        "duration_second",
        "title",
        "rate_change",
        "category",
        "updated_at"
    )
VALUES
    ($1, $2, $3, $4, $5, $6, NOW())
ON CONFLICT ("contest_id") DO
UPDATE
SET
    "start_epoch_second" = EXCLUDED."start_epoch_second",
    "duration_second" = EXCLUDED."duration_second",
    "title" = EXCLUDED."title",
    "rate_change" = EXCLUDED."rate_change",
    "category" = EXCLUDED."category",
    "updated_at" = NOW()
`

type InsertContestParams struct {
	ContestID        string `bulk:"unique" db:"contest_id"`
	StartEpochSecond int64  `db:"start_epoch_second"`
	DurationSecond   int64  `db:"duration_second"`
	Title            string `db:"title"`
	RateChange       string `db:"rate_change"`
	Category         string `db:"category"`
}

func (q *Queries) InsertContest(ctx context.Context, arg InsertContestParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, insertContest,
		arg.ContestID,
		arg.StartEpochSecond,
		arg.DurationSecond,
		arg.Title,
		arg.RateChange,
		arg.Category,
	)
}

const insertDifficulty = `-- name: InsertDifficulty :execresult
INSERT INTO
    "difficulties" (
        "problem_id",
        "slope",
        "intercept",
        "variance",
        "difficulty",
        "discrimination",
        "irt_loglikelihood",
        "irt_users",
        "is_experimental",
        "updated_at"
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW())
ON CONFLICT ("problem_id") DO
UPDATE
SET
    "slope" = EXCLUDED."slope",
    "intercept" = EXCLUDED."intercept",
    "variance" = EXCLUDED."variance",
    "difficulty" = EXCLUDED."difficulty",
    "discrimination" = EXCLUDED."discrimination",
    "irt_loglikelihood" = EXCLUDED."irt_loglikelihood",
    "irt_users" = EXCLUDED."irt_users",
    "is_experimental" = EXCLUDED."is_experimental",
    "updated_at" = NOW()
`

type InsertDifficultyParams struct {
	ProblemID        string   `bulk:"unique" db:"problem_id"`
	Slope            *float64 `db:"slope"`
	Intercept        *float64 `db:"intercept"`
	Variance         *float64 `db:"variance"`
	Difficulty       *int64   `db:"difficulty"`
	Discrimination   *float64 `db:"discrimination"`
	IrtLoglikelihood *float64 `db:"irt_loglikelihood"`
	IrtUsers         *float64 `db:"irt_users"`
	IsExperimental   *bool    `db:"is_experimental"`
}

func (q *Queries) InsertDifficulty(ctx context.Context, arg InsertDifficultyParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, insertDifficulty,
		arg.ProblemID,
		arg.Slope,
		arg.Intercept,
		arg.Variance,
		arg.Difficulty,
		arg.Discrimination,
		arg.IrtLoglikelihood,
		arg.IrtUsers,
		arg.IsExperimental,
	)
}

const insertProblem = `-- name: InsertProblem :execresult
INSERT INTO
    "problems" (
        "problem_id",
        "contest_id",
        "problem_index",
        "name",
        "title",
        "url",
        "html",
        "created_at",
        "updated_at"
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7, NOW(), NOW())
ON CONFLICT ("problem_id") DO
UPDATE
SET
    "contest_id" = EXCLUDED."contest_id",
    "problem_index" = EXCLUDED."problem_index",
    "name" = EXCLUDED."name",
    "title" = EXCLUDED."title",
    "url" = EXCLUDED."url",
    "html" = EXCLUDED."html",
    "updated_at" = NOW()
`

type InsertProblemParams struct {
	ProblemID    string `bulk:"unique" db:"problem_id"`
	ContestID    string `db:"contest_id"`
	ProblemIndex string `db:"problem_index"`
	Name         string `db:"name"`
	Title        string `db:"title"`
	Url          string `db:"url"`
	Html         string `db:"html"`
}

func (q *Queries) InsertProblem(ctx context.Context, arg InsertProblemParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, insertProblem,
		arg.ProblemID,
		arg.ContestID,
		arg.ProblemIndex,
		arg.Name,
		arg.Title,
		arg.Url,
		arg.Html,
	)
}

const insertSubmission = `-- name: InsertSubmission :execresult
INSERT INTO
    "submissions" (
        "id",
        "epoch_second",
        "problem_id",
        "contest_id",
        "user_id",
        "language",
        "point",
        "length",
        "result",
        "execution_time",
        "crawled_at"
    )
VALUES
    ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW())
ON CONFLICT ("id") DO
UPDATE
SET
    "epoch_second" = EXCLUDED."epoch_second",
    "problem_id" = EXCLUDED."problem_id",
    "contest_id" = EXCLUDED."contest_id",
    "user_id" = EXCLUDED."user_id",
    "language" = EXCLUDED."language",
    "point" = EXCLUDED."point",
    "length" = EXCLUDED."length",
    "result" = EXCLUDED."result",
    "execution_time" = EXCLUDED."execution_time",
    "crawled_at" = NOW()
`

type InsertSubmissionParams struct {
	ID            int64    `bulk:"unique" db:"id"`
	EpochSecond   int64    `db:"epoch_second"`
	ProblemID     string   `db:"problem_id"`
	ContestID     *string  `db:"contest_id"`
	UserID        *string  `db:"user_id"`
	Language      *string  `db:"language"`
	Point         *float64 `db:"point"`
	Length        *int32   `db:"length"`
	Result        *string  `db:"result"`
	ExecutionTime *int32   `db:"execution_time"`
}

func (q *Queries) InsertSubmission(ctx context.Context, arg InsertSubmissionParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, insertSubmission,
		arg.ID,
		arg.EpochSecond,
		arg.ProblemID,
		arg.ContestID,
		arg.UserID,
		arg.Language,
		arg.Point,
		arg.Length,
		arg.Result,
		arg.ExecutionTime,
	)
}

const insertUser = `-- name: InsertUser :execresult
INSERT INTO
    "users" (
        "user_name",
        "rating",
        "highest_rating",
        "affiliation",
        "birth_year",
        "country",
        "crown",
        "join_count",
        "rank",
        "active_rank",
        "wins",
        "created_at",
        "updated_at"
    )
VALUES
    (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        NOW(),
        NOW()
    )
ON CONFLICT ("user_name") DO
UPDATE
SET
    "rating" = EXCLUDED."rating",
    "highest_rating" = EXCLUDED."highest_rating",
    "affiliation" = EXCLUDED."affiliation",
    "birth_year" = EXCLUDED."birth_year",
    "country" = EXCLUDED."country",
    "crown" = EXCLUDED."crown",
    "join_count" = EXCLUDED."join_count",
    "rank" = EXCLUDED."rank",
    "active_rank" = EXCLUDED."active_rank",
    "wins" = EXCLUDED."wins",
    "created_at" = NOW(),
    "updated_at" = NOW()
`

type InsertUserParams struct {
	UserName      string  `bulk:"unique" db:"user_name"`
	Rating        int32   `db:"rating"`
	HighestRating int32   `db:"highest_rating"`
	Affiliation   *string `db:"affiliation"`
	BirthYear     *int32  `db:"birth_year"`
	Country       *string `db:"country"`
	Crown         *string `db:"crown"`
	JoinCount     int32   `db:"join_count"`
	Rank          int32   `db:"rank"`
	ActiveRank    *int32  `db:"active_rank"`
	Wins          int32   `db:"wins"`
}

func (q *Queries) InsertUser(ctx context.Context, arg InsertUserParams) (pgconn.CommandTag, error) {
	return q.db.Exec(ctx, insertUser,
		arg.UserName,
		arg.Rating,
		arg.HighestRating,
		arg.Affiliation,
		arg.BirthYear,
		arg.Country,
		arg.Crown,
		arg.JoinCount,
		arg.Rank,
		arg.ActiveRank,
		arg.Wins,
	)
}

const updateBatchHistory = `-- name: UpdateBatchHistory :exec
UPDATE "batch_history"
SET
    "finished_at" = NOW(),
    "status" = $1
WHERE
    "id" = $2
`

type UpdateBatchHistoryParams struct {
	Status *string `db:"status"`
	ID     int64   `db:"id"`
}

func (q *Queries) UpdateBatchHistory(ctx context.Context, arg UpdateBatchHistoryParams) error {
	_, err := q.db.Exec(ctx, updateBatchHistory, arg.Status, arg.ID)
	return err
}
